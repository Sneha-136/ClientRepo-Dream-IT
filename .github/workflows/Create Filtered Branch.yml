# ============================================
# CONFIGURATION - EDIT ONLY THIS SECTION
# ============================================

name: Create Truly Isolated Filtered Branch

# Run manually only
on:
  workflow_dispatch:
    inputs:
      source_branch:
        description: 'Source branch to filter from'
        required: true
        default: 'main'
      new_branch:
        description: 'Name for the new filtered branch'
        required: true
        default: 'filtered-branch'
      folders_to_keep:
        description: 'Comma-separated EXACT folder names (e.g., BusinessCentral,Shopify)'
        required: true
        default: 'BusinessCentral,Shopify'

# ============================================
# WORKFLOW CODE - DON'T EDIT BELOW
# ============================================

jobs:
  create-isolated-filtered-branch:
    runs-on: ubuntu-latest
    
    steps:
    # STEP 1: Checkout with FULL history
    # FIX: Changed fetch-depth from 1 to 0 to get all commits
    # WHY: We need access to source branch commits to copy folders
    - name: Checkout source code with full history
      uses: actions/checkout@v3
      with:
        ref: ${{ github.event.inputs.source_branch }}
        fetch-depth: 0  # FIX #1: Get ALL history, not just latest commit
        token: ${{ secrets.PAT_GITHUB }}

    # STEP 2: Fetch all remote branches explicitly
    # FIX: Ensure we have all remote branches available
    # WHY: Orphan branch might lose track of remote branches
    - name: Fetch all branches
      run: |
        echo "ğŸ“¡ Fetching all remote branches..."
        git fetch --all
        echo "âœ… All branches fetched"
        echo ""
        echo "Available branches:"
        git branch -a

    # STEP 3: Configure Git identity
    - name: Configure Git
      run: |
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"

    # STEP 4: Delete remote branch if it exists
    # FIX: Prevent conflicts with existing branch
    # WHY: If branch exists with history, orphan might fail
    - name: Delete existing remote branch (if any)
      continue-on-error: true
      run: |
        echo "ğŸ—‘ï¸  Checking if branch exists remotely..."
        if git ls-remote --heads origin ${{ github.event.inputs.new_branch }} | grep -q ${{ github.event.inputs.new_branch }}; then
          echo "Branch exists, deleting..."
          git push origin --delete ${{ github.event.inputs.new_branch }} || echo "Could not delete remote branch"
        else
          echo "Branch does not exist remotely, continuing..."
        fi

    # STEP 5: Show available folders in source branch
    # FIX: List actual folder names for debugging
    # WHY: Help identify case sensitivity or name issues
    - name: List available folders in source branch
      run: |
        echo "============================================"
        echo "ğŸ“‚ Folders available in ${{ github.event.inputs.source_branch }}:"
        echo "============================================"
        git ls-tree -d --name-only origin/${{ github.event.inputs.source_branch }} | while read folder; do
          echo "   â€¢ $folder"
        done
        echo ""

    # STEP 6: Store source branch SHA
    # FIX: Use explicit commit SHA instead of branch name
    # WHY: More reliable reference that won't change
    - name: Get source branch SHA
      id: source_sha
      run: |
        SHA=$(git rev-parse origin/${{ github.event.inputs.source_branch }})
        echo "Source SHA: $SHA"
        echo "sha=$SHA" >> $GITHUB_OUTPUT

    # STEP 7: Create ORPHAN branch (completely disconnected)
    - name: Create orphan branch (isolated from main)
      run: |
        echo "============================================"
        echo "ğŸŒ¿ Creating ORPHAN branch"
        echo "============================================"
        echo "Branch name: ${{ github.event.inputs.new_branch }}"
        echo "Source: ${{ github.event.inputs.source_branch }}"
        echo "Source SHA: ${{ steps.source_sha.outputs.sha }}"
        echo ""
        
        # Create orphan branch - NO parent commits
        git checkout --orphan ${{ github.event.inputs.new_branch }}
        
        echo "âœ… Orphan branch created"
        echo "Current branch: $(git branch --show-current)"

    # STEP 8: Remove ALL files from staging and working directory
    # FIX: Use more aggressive cleanup
    # WHY: Orphan branches start with all files staged
    - name: Clear all files completely
      run: |
        echo "ğŸ—‘ï¸  Removing all files..."
        
        # Remove from git staging
        git rm -rf . --quiet 2>/dev/null || true
        
        # Remove from working directory (except .git)
        find . -not -path './.git/*' -not -name '.git' -delete 2>/dev/null || true
        
        echo "âœ… All files removed"
        ls -la

    # STEP 9: Copy ONLY specified folders using SHA reference
    # FIX: Use SHA instead of branch name, strip trailing slashes
    # WHY: More reliable, handles all edge cases
    - name: Copy only specified folders
      run: |
        echo "============================================"
        echo "ğŸ“‚ Copying folders from source"
        echo "============================================"
        echo ""
        
        # Convert comma-separated list to array
        IFS=',' read -ra FOLDERS <<< "${{ github.event.inputs.folders_to_keep }}"
        
        # Process each folder
        copied_count=0
        failed_count=0
        
        for folder in "${FOLDERS[@]}"; do
            # FIX #5: Strip whitespace AND trailing slashes
            folder=$(echo "$folder" | xargs | sed 's:/*$::')
            
            echo "Processing: $folder"
            
            # FIX #2: Use SHA reference instead of branch name
            # Check if folder exists using SHA
            if git ls-tree -d ${{ steps.source_sha.outputs.sha }} "$folder" &>/dev/null; then
                echo "   âœ“ Found: $folder/"
                
                # FIX #3: Use git show and tar to copy (works on orphan branches)
                echo "   â†“ Copying files..."
                
                # Create folder structure
                mkdir -p "$folder"
                
                # Extract files using git archive (most reliable method)
                git archive ${{ steps.source_sha.outputs.sha }} "$folder" | tar -x
                
                if [ $? -eq 0 ]; then
                    echo "   âœ… Copied successfully"
                    copied_count=$((copied_count + 1))
                else
                    echo "   âŒ Copy failed"
                    failed_count=$((failed_count + 1))
                fi
            else
                echo "   âœ— NOT FOUND: $folder/ (case-sensitive check failed)"
                failed_count=$((failed_count + 1))
                
                # Try case-insensitive search
                echo "   ğŸ” Searching case-insensitively..."
                git ls-tree -d --name-only ${{ steps.source_sha.outputs.sha }} | grep -i "^${folder}$" | while read found_folder; do
                    echo "   ğŸ’¡ Did you mean: $found_folder ?"
                done
            fi
            echo ""
        done
        
        echo "ğŸ“Š Copy Summary:"
        echo "   â€¢ Successfully copied: $copied_count"
        echo "   â€¢ Failed/Not found: $failed_count"
        echo ""

    # STEP 10: Verify copied files
    - name: Show copied structure
      run: |
        echo "============================================"
        echo "ğŸ“‚ Files in new isolated branch:"
        echo "============================================"
        
        if [ -z "$(find . -type f -not -path './.git/*' 2>/dev/null)" ]; then
            echo "âŒ ERROR: No files were copied!"
            echo ""
            echo "Troubleshooting:"
            echo "1. Check folder names are EXACT (case-sensitive)"
            echo "2. Check folders exist in source branch"
            echo "3. Review logs above for specific errors"
            exit 1
        else
            echo "Files copied:"
            find . -type f -not -path './.git/*' | sort | while read file; do
                echo "   âœ“ $file"
            done
            
            echo ""
            echo "ğŸ“Š Summary:"
            file_count=$(find . -type f -not -path './.git/*' | wc -l)
            folder_count=$(find . -mindepth 1 -maxdepth 1 -type d -not -name '.git' | wc -l)
            echo "   â€¢ Total files: $file_count"
            echo "   â€¢ Total folders: $folder_count"
        fi
        echo ""

    # STEP 11: Stage all copied files
    # FIX: Use git add -A to catch everything
    # WHY: More comprehensive than git add .
    - name: Stage all files
      run: |
        echo "ğŸ“ Staging all files..."
        
        # FIX #7: Use -A flag to add all changes
        git add -A
        
        echo "âœ… Files staged"
        git status

    # STEP 12: Create initial commit
    - name: Create initial isolated commit
      run: |
        echo "ğŸ’¾ Creating initial commit..."
        
        # Verify we have something to commit
        if git diff --cached --quiet; then
            echo "âŒ ERROR: Nothing to commit!"
            exit 1
        fi
        
        # Create commit
        TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
        git commit -m "Initial isolated commit | Folders: ${{ github.event.inputs.folders_to_keep }} | Source: ${{ github.event.inputs.source_branch }} @ ${{ steps.source_sha.outputs.sha }} | Type: ORPHAN | Time: $TIMESTAMP"
        
        echo "âœ… Initial commit created"
        
        # Show commit info
        echo ""
        echo "Commit details:"
        git log --oneline -1

    # STEP 13: Verify orphan status
    - name: Verify branch is truly orphan
      run: |
        echo "ğŸ” Verifying orphan status..."
        
        # Check if branch has parent
        if git rev-parse HEAD^ &>/dev/null; then
            echo "âŒ WARNING: Branch has parent commits (NOT ORPHAN!)"
            git log --oneline --graph --all
            exit 1
        else
            echo "âœ… Confirmed: Branch is ORPHAN (no parent commits)"
        fi
        
        # Show commit count
        commit_count=$(git rev-list --count HEAD)
        echo "Total commits in branch: $commit_count (should be 1)"

    # STEP 14: Push the isolated branch
    - name: Push isolated branch to remote
      run: |
        echo "============================================"
        echo "ğŸš€ Pushing ORPHAN branch to remote"
        echo "============================================"
        echo ""
        
        # FIX #8: Force push to overwrite any existing branch
        git push origin ${{ github.event.inputs.new_branch }} --force
        
        echo ""
        echo "âœ… SUCCESS! Branch pushed"

    # STEP 15: Verify remote branch is orphan
    - name: Verify remote branch isolation
      run: |
        echo "============================================"
        echo "ğŸ” Final Verification"
        echo "============================================"
        echo ""
        
        # Fetch the branch we just pushed
        git fetch origin ${{ github.event.inputs.new_branch }}
        
        # Check if it shares history with source
        if git merge-base origin/${{ github.event.inputs.source_branch }} origin/${{ github.event.inputs.new_branch }} &>/dev/null; then
            echo "âŒ ERROR: Branches share common history!"
            echo "This means orphan creation failed"
            exit 1
        else
            echo "âœ… VERIFIED: No common ancestor found"
            echo "âœ… Branch is truly isolated"
        fi
        
        echo ""
        echo "============================================"
        echo "âœ… SUCCESS - ISOLATED BRANCH CREATED"
        echo "============================================"
        echo "ğŸ“‹ Branch: ${{ github.event.inputs.new_branch }}"
        echo "ğŸ”’ Type: Orphan (no shared history)"
        echo "ğŸ“ Contains: ${{ github.event.inputs.folders_to_keep }}"
        echo "ğŸš« Pull requests to ${{ github.event.inputs.source_branch }}: IMPOSSIBLE"
        echo "============================================"
